\documentclass[a4paper, 10pt, twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-ucroman, es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\usepackage[noend]{algpseudocode}
\usepackage{enumitem} % Provee macro \setlist
\usepackage[toc, page]{appendix}


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Trabajo Práctico 1 · Algoritmos y Estructuras de Datos III}
\rhead{Lovisolo · Petaccio · Rossi}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Configuración de Algorithmic - Inicio %%%%%%%%%%
% Entorno propio para customizar la presentación del pseudocódigo
\newenvironment{pseudo}[1][]{%
    \vspace{0.5em}%
    \begin{algorithmic}%
}
{%
    \end{algorithmic}%
    \vspace{0.5em}%
}

% Valores de verdad
\newcommand{\True}{\textbf{true}}
\newcommand{\False}{\textbf{false}}

% Conectivo 'in' para usar así: \ForAll{$foo$ \In $bar$}
\newcommand{\In}{\textbf{in} }

% Conectivo 'to' para usar así: \For{$i = 1$ \In $n$}
\newcommand{\To}{\textbf{to} }

% Complejidades
\newcommand{\Ode}[1]{\hfill $O(#1)$}
%%%%%%%%%% Configuración de Algorithmic - Fin %%%%%%%%%%


%%%%%%%%%% Miscelánea - Inicio %%%%%%%%%%
% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Deshabilita sangría en la primer línea de un párrafo.
\setlength{\parindent}{0em}

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}

% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}
%%%%%%%%%% Miscelánea - Fin %%%%%%%%%%


%%%%%%%%%% Gráficos - Inicio %%%%%%%%%%
% Macro para incluir tres gráficos (dentro de una figura) de manera que
% entren todos en una sola página.
\newcommand{\tresgraficos}[3]{
    \newcommand{\separacion}{-2.2em}
    \vspace{\separacion}
    \include{#1}
    \vspace{\separacion}
    \include{#2}
    \vspace{\separacion}
    \include{#3}
}
%%%%%%%%%% Gráficos - Fin %%%%%%%%%%


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
Trabajo Práctico 2
\end{Huge}

\vspace{0.5cm}

\begin{Large}
Algoritmos y Estructuras de Datos III
\end{Large}

\vspace{1cm}

Segundo Cuatrimestre de 2013

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Leandro Lovisolo      & 645/11 & leandro@leandro.me\\
Lautaro José Petaccio & 443/11 & lausuper@gmail.com\\
Lucas Rossi           & 705/11 & lucasrossi20@gmail.com\\
\hline
\end{tabular}

\end{center}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Índice                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introducción}

En el presente trabajo estudiamos tres problemas algorítmicos, proponemos soluciones para los mismos respetando sus requerimientos de complejidad temporal y analizamos empíricamente los tiempos de ejecución de sus implementaciones en lenguaje C++.

La motivación de este trabajo es comparar las cotas temporales obtenidas del análisis teórico con las mediciones de tiempos de ejecución y extraer conclusiones de esta experimentación.

Sin más, presentamos los problemas estudiados a continuación.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 1: Impresiones ordenadas                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Problema 1: Impresiones ordenadas}

Una imprenta dispone de dos máquinas para realizar impresiones a gran escala. Los trabajos realizados pueden ser muy distintos entre sí y para realizarlos, las máquinas requieren que se las prepare para ello. La preparación para realizar un trabajo tiene un costo que va a depender del trabajo que se haya realizado previamente en la impresora.\\

Se nos pide realizar un algoritmo que minimice el costo de realizar una serie de trabajos $t_1$...$t_n$ en el orden que vienen dados con una complejidad temporal de \textbf{peor caso O($n^2$)}.

\textbf{Ejemplos del problema y sus soluciones:}
\begin{enumerate}
\item{\textbf{Entrada}:}
\begin{itemize}
\item{Trabajo 1: $c_{01}$: 1}
\item{Trabajo 2: $c_{02}$: 2, $c_{12}$: 4}
\item{Trabajo 3: $c_{03}$: 3, $c_{13}$: 5, $c_{23}$: 6}
\end{itemize}
\textbf{Salida}:
\begin{itemize}
\item{Costo total: 8}
\item{Cantidad de trabajos asociados a la máquina 1: 2}
\item{Trabajos realizados en la máquina 1: 1 y 3}
\end{itemize}


\item{\textbf{Entrada}:}
\begin{itemize}
\item{Sin trabajos}
\end{itemize}
\textbf{Salida}:
\begin{itemize}
\item{Costo total: 0}
\item{Cantidad de trabajos asociados a la máquina 1: 0}
\item{Trabajos realizados en la máquina 1: 0}
\end{itemize}
\end{enumerate}

\subsection{Solución}

Dado una serie de trabajos $t_1$...$t_n$, donde cada trabajo $t_i$ está asociado al costo de preparación del trabajo luego de haber realizado el trabajo $t_j$ para cada par de trabajos $t_i$ y $t_j$ con $j<i$ y al costo de preparación si el trabajo es el primero realizado en la máquina.

\subsubsection{Pseudocódigo}

\begin{pseudo}

\State trabajos: vector de enteros
\State costos: matriz de enteros
\State dp: matriz de enteros
\\
\Procedure{Impresiones-ordenadas}{n: entero, costos: c}
    \For{int j = n - 1; j $>$= 0; j$--$}
        \For{int i = 0; i $<$ n; i$++$}
            \If{i == 0 $\&\&$ j == 0}                 \Ode{1}
                \State dp[0][0] = dp[0][1] + c[0][1]  \Ode{1}
                \State break                          
            \EndIf
            \If{i == j}                               \Ode{1}
                \State break
            \EndIf
            \State dp[i][j] = min(dp[i][j + 1] + c[j][j + 1], dp[j][j + 1] + c[i][j + 1])                          \Ode{1}
        \EndFor
    \EndFor
    \State costo\_minimo = dp[0][0]                    \Ode{1}
    \State i = 0                                       \Ode{1}
    \State j = 1                                       \Ode{1}
    \State trabajos$.$agregar\_atras(1);
    \While{j $<$ n}
        \If{dp[i][j] == dp[i][j + 1] + c[j][j + 1]}    \Ode{1}
            \If{trabajos$.$ultimo() == (trabajo) j}    \Ode{1}
            \State trabajos$.$agregar\_atras(j + 1)    \Ode{1}
            \State j++                                 \Ode{1}
            \EndIf
        \Else
            \If{trabajos$.$ultimo() == (trabajo) i}    \Ode{1}
            \State trabajos$.$agregar\_atras(j + 1)    \Ode{1}
            \State i = j                               \Ode{1}  
            \State j++                                 \Ode{1}
            \EndIf
        \EndIf
    \EndWhile
    \Return par$<$costo\_minimo, trabajos$>$ \Ode{1}
    \EndProcedure
\end{pseudo}



\subsection{Complejidad}

Para realizar el algoritmo se utilizó la estructura de datos \textbf{vector} que pertenece a la STD de C++.

Las operaciones realizadas fueron \textbf{push\_back()} y \textbf{agregar\_atras()} que corresponden a \textbf{back()} y \textbf{ultimo()} con complejidad O(1).

El algoritmo corre en tiempo O($n^2$), donde $n$ es la cantidad de trabajos.

\textbf{Demostración: }

\subsection{Correctitud}

\subsection{Experimentos computacionales}
\subsubsection{Verificación de correctitud}

Elegimos los siguientes casos para verificar la correctitud del programa:

\begin{enumerate}
\item{}
\item{}
\end{enumerate}
\subsubsection{Performance}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 2: Recopilación de contenido                                     %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Problema 2: Recopilación de contenido}

Dado $n$ servidores interconectados mediante $m$ enlaces de alta velocidad, una organización debe implementar una solución de replicación de contenido para su red. Para esto, se selecciona un servidor como \textbf{master}, que será el primero en recibir los datos a replicar. Luego, la información será transmitida a otros servidores que, se guardarán una copia y retrasmitiran los datos hasta que los $n$ servidores tengan la nueva información. El uso de los enlaces tiene un costo en función del tráfico que transmiten.

Se nos pide:
\begin{itemize}
    \item{elegir los enlaces que se deberán utilizar de manera que la información pueda distribuirse a todos los servidores con un costo mínimo, con una complejidad temporal de \textbf{peor caso estrictamente menor que O($n^3$).}}
    \item{definir que servidor seleccionar como \textbf{master} de manera que la replicación termine en el menor tiempo posible, con una complejidad temporal de \textbf{peor caso O($n$).}}
\end{itemize}

\textbf{Ejemplos del problema y sus soluciones:}

\textbf{Entrada}:. \\
\textbf{Salida}: . \\

\textbf{Entrada}:. \\
\textbf{Salida}: . \\

\subsection{Minimizar costo de enlaces}

\subsubsection{Solución}

\subsubsection{Complejidad}
Para la implementación del algoritmo de Kruskal, se utilizó la estructura Disjoint-Set, compuesta por las funciones Make\_union() y Find() y 3 arreglos de longitud cantidad de nodos.
La función Find() consiste en una función recursiva la cual recorre los padres del nodo para ver encontrar el nodo que define al conjunto. En cada entrada a la función, se realiza un procedimiento llamado compresión de caminos. Cuando se utiliza la función, actualiza el nodo de donde se llamó y todos los nodos que recorre, con el nodo representante del conjunto.

La función Make\_union realiza una unión de dos subconjuntos. La operación de unión se da sobre el nodo de ranking menor, es decir, el nodo que tenga menos hojas, haciendo que cada unión quede lo más cercana a la raíz posible, comprimiendo distancias.

Mediante la utilización de estas dos funciones se logra que cada llamada a estas tenga una complejidad amortizada de O($\alpha(n)$), donde $\alpha$ corresponde a la función de Ackermann para la cual $\alpha(n)$ es menor a 5 para casi todos los n utilizados en la práctica, haciendo que las operaciones tengan una complejidad de O(1) amortizada.

Para realizar el ordenamiento, se obtiene una complejidad de O(m log m) utilizando Sort() de la STL, que por ser m a lo sumo $n^2$, O(m log m) $\subset$ O(m log $n^2$) $\subset$ O(m 2*log n) $\subset$ O(m log n) $\subset$ O($n^2$ log n) que es estrictamente menor a O($n^3$).

Como las operaciones sobre la estructura Disjoint-Set se realizan a lo sumo $m$ veces, se obtiene una complejidad de O($m$) para conseguir el AGM.

\subsubsection{Correctitud}

\subsection{Minimizar el tiempo de replicación}

\subsubsection{Solución}

\subsubsection{Complejidad}

\subsubsection{Correctitud}

\subsubsection{Experimentos computacionales}

\paragraph{Verificación de correctitud}

\paragraph{Performance}

\subsection{Preguntas adicionales}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Problema 3: Transportes pesados                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Problema 3: Transportes pesados}

Una empresa que fabrica ladrillos tiene sus fábricas en varios puntos de una provincia. La misma se encarga de transportar los ladrillos a los clientes que están distribuísdos en distintas ciudades de la provincia.\\
Como las rutas de esta provincia no están preparadas para soportar el paso de los camiones, la empresa tiene que fortalecer las rutas para que puedan ser utilizadas por los camiones.\\
Dado que cada ruta tiene un costo de inversión proporcional a la longitud de la misma, se pide replanificar las rutas habituales de manera tal de minimizar los gastos que implicará el fortalecimiento de las rutas para que cada cliente pueda ser provisto desde al menos una fábrica.\\
La complejidad temporal del \textbf{peor caso} deberá ser \textbf{O($C^2$)} o bien \textbf{O(R$log$(C)).}

\textbf{Ejemplos del problema y sus soluciones:}

\textbf{Entrada}: . \\
\textbf{Salida}: . \\

\textbf{Entrada}: . \\
\textbf{Salida}: . \\

\subsection{Solución}


\subsubsection{Pseudocódigo}
\begin{pseudo}

\State parent : vector de enteros
\State ranking : vector de enteros
\State fabrica : vector de enteros
\State $tupla <entero, entero>$ es $DatosPadre$
\\
\Procedure{find}{x: entero} $\rightarrow$ DatosPadre
	\If{x != parent[x]}											\Ode{1}
		\State DatosPadre P = Find(parent$[x]$)					\Ode{1}
    	\State parent$[x]$ = P.first							\Ode{1}
	    \State fabrica$[x]$ = P.second							\Ode{1}
    \EndIf
    \Return $tupla <parent[x], fabrica[x]>$						\Ode{1}
\EndProcedure

\\
\Procedure{make\_union}{x : entero, y : entero}
    \State DatosPadre set\_x = Find(x)
    \State DatosPadre set\_y = Find(y)
    
    \If{ranking$[set_x.first]$ $>$ ranking$[set\_y.first]$}		\Ode{1}
        \State parent$[set\_y.first]$ = set\_x.first			\Ode{1}
    \Else
        \State parent$[set\_x.first]$ = set\_y.first			\Ode{1}
    \EndIf
    
    \If{ranking$[set\_x.first]$ == ranking$[set\_y.first]$}		\Ode{1}
        \State ranking$[set\_y.first]++$						\Ode{1}
	\EndIf

    \If{set\_x.second != inf}									\Ode{1}
    	\State fabrica$[set\_y.first]$ = set\_x.second			\Ode{1}
    \Else
    	\State fabrica$[set\_x.first]$ = set\_y.second			\Ode{1}
    \EndIf
\EndProcedure

\\

\State $tupla <nodo1 : entero, nodo2 : entero, costo : entero>$ es $ruta$
\Procedure{problema3}{cantNodos : entero, cantFabricas : entero, rutas: vector de ruta} $\rightarrow$ vector de ruta
	\State camino\_minimo : vector de rutas						\Ode{R}
	\For{i = 0 To Tamaño(parent)} parent$[i]$ = 0 \EndFor
	\For{i = 0 To Tamaño(parent)} ranking$[i]$ = 0 \EndFor
	\For{i = 0 To cantFabricas} fabrica$[i]$ = i \EndFor
	\For{i = cantFabricas To cantNodos} fabrica$[i]$ = 0 \EndFor
	\State Ordenar(rutas) en orden ascendente por costo			\Ode{R * log R}	
	
	\For{i = 0 To tamaño(rutas)}
		\State DatosPadre set1 = Find(nodo1(rutas$[i]$));		\Ode{1}
        \State DatosPadre set2 = Find(nodo2(rutas$[i]$));		\Ode{1}
	    \If{(set1.first != set2.first) AND !(set1.second != inf AND set2.second != inf))} \Ode{1}
	    	\State Make\_union(set1.first, set2.first)			\Ode{1}
	    	\State camino\_minimo.Agregar(rutas$[i]$)			\Ode{1}
	    \EndIf
	\EndFor
	\Return camino\_minimo
\EndProcedure

\end{pseudo}
\subsection{Complejidad}
Debido a que para el ordenamiento de las rutas, utilizamos la función Sort() de la STL, se obtiene una costo de O(R * log R), siendo R rutas, lo que equivale a O(R * log $(C+F)^2$), siendo C clientes y F fábricas por ser C+F la mayor cantidad de aristas posibles. Por ser F menor que C, O(F) $\subset$ O(C), log($(C+F)^2$) $\subset$ log($C^2$). Siendo O($C^2$) la cota superior para la cantidad de aristas, la complejidad equivale a O(R * 2 log C) $\subset$ O(R * log C).

Como se utiliza el algoritmo de Kruskal, al igual que en el segundo problema, la complejidad de obtener los subconjuntos de rutas que unen clientes con fábricas es de O(R).

Como O(R) $\subset$ O(R * log C), la complejidad final del algoritmo es O(R * log C).
\subsection{Correctitud}

\subsection{Experimentos computacionales}
\subsubsection{Verificación de correctitud}

\subsubsection{Performance}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusiones                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Conclusiones}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 1                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\begin{appendices}

\section{Código fuente para el problema 1}


\subsection{problema1.h}

\subsection{problema1.cpp}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 2                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Código fuente para el problema 2}


\subsection{problema2.h}

\subsection{problema2.cpp}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Código fuente para el problema 3                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Código fuente para el problema 3}


\subsection{problema3.h}

\subsection{problema3.cpp}


\end{appendices}

\end{document}